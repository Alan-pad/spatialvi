---
title: "nf-core/spatialtranscriptomics"
subtitle: "Pre-processing and quality controls"
format:
  nf-core-html: default
jupyter: python3
---

## Introduction

Spatial Transcriptomics data analysis involves several steps, including quality
controls (QC) and pre-processing, to ensure the reliability of downstream
analyses. This is an essential step in spatial transcriptomics to
identify and filter out spots and genes that may introduce noise and/or bias
into the analysis.

This report outlines the QC and pre-processing steps for Visium Spatial
Transcriptomics data using the [anndata format](https://anndata.readthedocs.io/en/latest/tutorials/notebooks/getting-started.html).
The anndata format is utilized to organize and store the Spatial Transcriptomics
data. It includes information about counts, features, observations, and
additional metadata. The anndata format ensures compatibility with various
analysis tools and facilitates seamless integration into existing workflows.

```{python}
#| tags: [parameters]
#| echo: false

fileNameST = None
resolution = 1
saveFileST = None

rawAdata = None  # Name of the h5ad file
minCounts = 500  # Min counts per spot
minGenes = 250  # Min genes per spot
minCells = 1  # Min cells per gene
histplotQCmaxTotalCounts = 10000  # Max total counts
histplotQCminGeneCounts = 4000  # Min gene counts
histplotQCbins = 40  # Number of bins
nHighlyVariableGenes = 2000  # Number of HVGs to use for analyses
nameDataNorm = "st_adata_norm.h5ad"  # Name of the normalized data save file
```

```{python}
import scanpy as sc
import scipy
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from IPython.display import display, Markdown
plt.rcParams["figure.figsize"] = (6, 6)
```

```{python}
# Read the data
st_adata = sc.read("./" + rawAdata)

# Convert X matrix from csr to csc dense matrix for output compatibility:
st_adata.X = scipy.sparse.csc_matrix(st_adata.X)

# Calculate mitochondrial and haemoglobin percentages
st_adata.var['mt'] = st_adata.var_names.str.startswith('MT-')
st_adata.var['hb'] = st_adata.var_names.str.contains(("^Hb.*-"))
sc.pp.calculate_qc_metrics(st_adata, qc_vars=["mt", "hb"], inplace=True)

# Save a copy of data as a restore-point if filtering results in 0 spots left
st_adata_before_filtering = st_adata.copy()

# Print the anndata object for inspection
print ("Content of the anndata object:")
st_adata
```

## Quality controls

The following plots show the distribution of the number of genes per counts and
counts per spot, as well as the percentage of counts from mitochondrial genes
and haemoglobin genes.

```{python}
#| layout-nrow: 2
sc.pl.violin(st_adata, ['n_genes_by_counts', 'total_counts'],
             multi_panel=True, jitter=0.4, rotation= 45)
sc.pl.violin(st_adata, ['pct_counts_mt', 'pct_counts_hb'],
             multi_panel=True, jitter=0.4, rotation= 45)
```

The same can be plotted on top of the tissue:

```{python}
#| layout-nrow: 2
sc.pl.spatial(st_adata, color = ["total_counts", "n_genes_by_counts"])
sc.pl.spatial(st_adata, color = ["pct_counts_mt", "pct_counts_hb"])
```

## Filtering

### In-tissue filtering

Spots outside the tissue are not needed and are thus removed.

```{python}
# Create a string observation "obs/in_tissue_str" with "In tissue" and "Outside tissue":
st_adata.obs["in_tissue_str"] = ["In tissue" if x == 1 else "Outside tissue" for x in st_adata.obs["in_tissue"]]

# Plot spots inside tissue
sc.pl.spatial(st_adata, color=["in_tissue_str"], title="Spots in tissue")
del st_adata.obs["in_tissue_str"]

# Remove spots outside tissue and print results
Number_spots = st_adata.shape[0]
st_adata = st_adata[st_adata.obs["in_tissue"] == 1]
Number_spots_in_tissue = st_adata.shape[0]
print (f"{Number_spots_in_tissue} spots in tissue on {Number_spots} spots in total.")
```

Distribution of counts per spots and genes per counts.

```{python}
#| fig-cap: "Top row: Distribution of the number of counts per spots. Bottom row: Distribution of the number of genes with at least 1 count in a spot."
fig, axs = plt.subplots(2, 2, figsize=(8, 7))
sns.histplot(
    st_adata.obs["total_counts"],
    kde=True,
    ax=axs[0, 0]
    ).set(title=f"Total counts")
sns.histplot(
    st_adata.obs["total_counts"][st_adata.obs["total_counts"] < histplotQCmaxTotalCounts],
    kde=True,
    bins=histplotQCbins,
    ax=axs[0, 1]
    ).set(title=f"Total counts < {histplotQCmaxTotalCounts}")
sns.histplot(
    st_adata.obs["n_genes_by_counts"],
    kde=True,
    bins=histplotQCbins,
    ax=axs[1, 0]
    ).set(title=f"Genes by counts")
sns.histplot(
    st_adata.obs["n_genes_by_counts"][st_adata.obs["n_genes_by_counts"] < histplotQCminGeneCounts],
    kde=True,
    bins=histplotQCbins,
    ax=axs[1, 1]
    ).set(title=f"Genes by counts < {histplotQCminGeneCounts}")
fig.tight_layout()
```

### Cell and gene filtering

We filter cells based on minimum counts and genes, and filter genes based on minimum cells.

```{python}
#| warning: false

# Filter cells based on counts
Number_spots = st_adata.shape[0]
Number_genes = st_adata.shape[1]
sc.pp.filter_cells(st_adata, min_counts=minCounts)
Number_spots_filtered_minCounts = st_adata.shape[0]
print (f"Removed {Number_spots - Number_spots_filtered_minCounts} spots with less than {minCounts} total counts.")

# Filter cells based on genes
sc.pp.filter_cells(st_adata, min_genes=minGenes)
Number_spots_filtered_minGenes = st_adata.shape[0]
print (f"Removed {Number_spots_filtered_minCounts - Number_spots_filtered_minGenes} spots with less than {minGenes} genes expressed.")

# Filter genes based on cells
sc.pp.filter_genes(st_adata, min_cells=minCells)
Number_genes_filtered_minCells = st_adata.shape[1]
print (f"Removed {Number_genes - Number_genes_filtered_minCells} genes expressed in less than {minCells} spots.")

print (f"{Number_spots_filtered_minGenes} out of {Number_spots} spots remaining after filtering.")
print (f"{Number_genes_filtered_minCells} out of {Number_genes} genes remaining after filtering.")
```

```{python}
#| echo: false
# Restore non-filtered data if filtering results in 0 spots left
if (Number_genes_filtered_minCells == 0 or Number_spots_filtered_minGenes == 0):
    st_adata = st_adata_before_filtering
    display(
        Markdown("""
::: {.callout-important .content-visible when-format="html"}
## Issue: No Spots Remain After Filtering

An anomaly has been detected in the data: following the filtering process,
all spots have been excluded. It is imperative to assess the data quality
and carefully review the Analysis Options outlined in `docs/usage.md`.

To ensure the smooth progression of downstream analysis, the exported
AnnData will, for the time being, remain unfiltered. This precautionary
measure is implemented to facilitate continued analysis while
investigating and resolving the cause of the unexpected removal of all
spots during filtering.
:::"""
        )
    )
```

Distributions after filtering:

```{python}
#| fig-cap: "Top row: Distribution of the number of counts per spots. Bottom row: Distribution of the number of genes with at least 1 count in a spot."
fig, axs = plt.subplots(2, 2, figsize=(8, 7))
sns.histplot(
    st_adata.obs["total_counts"],
    kde=True,
    ax=axs[0, 0]
    ).set(title=f"Total counts")
sns.histplot(
    st_adata.obs["total_counts"][st_adata.obs["total_counts"] < histplotQCmaxTotalCounts],
    kde=True,
    bins=histplotQCbins,
    ax=axs[0, 1]
    ).set(title=f"Total counts < {histplotQCmaxTotalCounts}")
sns.histplot(
    st_adata.obs["n_genes_by_counts"],
    kde=True,
    bins=histplotQCbins,
    ax=axs[1, 0]
    ).set(title=f"Genes by counts")
sns.histplot(
    st_adata.obs["n_genes_by_counts"][st_adata.obs["n_genes_by_counts"] < histplotQCminGeneCounts],
    kde=True,
    bins=histplotQCbins,
    ax=axs[1, 1]
    ).set(title=f"Genes by counts < {histplotQCminGeneCounts}")
fig.tight_layout()
```

### Normalization

We proceed to normalize Visium counts data using the built-in `normalize_total`
method from [Scanpy](https://scanpy.readthedocs.io/en/stable/) followed by a
log-transformation.

```{python}
sc.pp.normalize_total(st_adata, inplace=True)
sc.pp.log1p(st_adata)
```

### Top expressed genes

```{python}
# Plot top 20 most highly expressed genes
sc.pl.highest_expr_genes(st_adata, n_top=20)
```

### Highly variable genes

The top highly variable genes are detected for use in subsequent analyses.

```{python}
# layout-nrow: 1
# Find top HVGs and print results
sc.pp.highly_variable_genes(st_adata, flavor="seurat", n_top_genes=nHighlyVariableGenes)
var_genes_all = st_adata.var.highly_variable
print("Extracted highly variable genes: %d"%sum(var_genes_all))

# Plot the HVGs
plt.rcParams["figure.figsize"] = (4.5, 4.5)
sc.pl.highly_variable_genes(st_adata)
```

```{python}
#| echo: false
# Write normalized data to disk
st_adata.write(nameDataNorm)
```
